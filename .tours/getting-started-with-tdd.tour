{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "Getting started with TDD",
  "steps": [
    {
      "file": "src/index.spec.ts",
      "description": "Welcome to the 3rd edition of our Art of Code dojo. Today we will create a game os \"Mastermind\".\r\n\r\nOne of the goals is to use TDD to write our code, so let's start by writting our first test.\r\n\r\nOn Typescript/Javascript we can organize our tests by category by using the `describe` function. This function receives 2 arguments:\r\n- a string which identifies the test group\r\n- a function where we'll write our test\r\n\r\nTo start lets create an initial group to contain our tests, and lets call it `Mastermind`. The code looks as follows:\r\n\r\n```typescript\r\ndescribe(\"Mastermind\", function() {\r\n    // add tests here.\r\n});\r\n```",
      "line": 3
    },
    {
      "file": "src/index.spec.ts",
      "description": "We can start by adding our tests here, in the body of our second argument. To write a test you can use the `test` function that has the same signature as the `describe` one that we've just used:\r\n- a string with the name of the test.\r\n- a `function` with the actual test code.\r\n\r\nOur first test will look something like the following:\r\n\r\n```typescript\r\ntest(\"should be able to create a game of mastermind\", function() {\r\n    // test code goes here\r\n});\r\n```",
      "line": 4
    },
    {
      "file": "src/index.spec.ts",
      "description": "On TDD we use the \"red-green-refactor\" cycle to create our code. I'll explain each step as we go.\r\n\r\nThe first step is the **RED** one. On this step we'll write a test that fails. The test may fail for any reason, nor just because of a failling assertion. Ex.: The code my not compile because you're trying to use a function that doesn't exist yet.\r\n\r\nOn this step our focus is to design how our code API will look like. For example, we'll think on what functions we will need, what arguments those functions will receive, and what should be the returned value of those functions.\r\n\r\nEach test should target one behaviour of our code, but you don't necessarily need to write the whole test at once.\r\n\r\nLet's illustrate that by creating our test code as follows:\r\n```typescript\r\nlet game = new Mastermind();\r\n```",
      "line": 3,
      "selection": {
        "start": {
          "line": 3,
          "character": 1
        },
        "end": {
          "line": 4,
          "character": 1
        }
      }
    },
    {
      "file": "src/index.spec.ts",
      "description": "Here we made a couple of decisions, the first is that we'll write our game as a class and it will be called `Mastermind`. This test will fail if we try to run it, you can double check by running the following command on your terminal:\r\n\r\n>> npm test",
      "line": 3
    },
    {
      "file": "src/index.spec.ts",
      "description": "Now we're on the **GREEN** step, which means we just want to make the test pass as fast as possible. On this step, we don't care much about code quality or design, we just want to make the code pass.\r\n\r\nHere we'll think about the logic necessary to implement the behaviour we need on our code. In our current case it's easy enough, we'll just create a new class named `Mastermind`.\r\n\r\n```typescript\r\nclass Mastermind {\r\n\r\n}\r\n```\r\n\r\nNote that we're writing our implementation inside of the same file as the tests. This is **NOT** a common or good practice, we're doing this right now just for velocity and simplicity sake. We should move our implementation code to a separate file on one of our future `Refactor` steps.\r\n\r\nWe can verify that our test pass by running the following command again:\r\n\r\n>> npm test",
      "line": 9
    },
    {
      "file": "src/index.spec.ts",
      "description": "Now we move to the **REFACTOR** step. On this step is when we'll clean our code from duplications, properly design it, apply patterns and so on.\r\n\r\nRight now we don't have much to refactor, so let's leave the code as is for now and restart the cycle, going to the next **RED** step.\r\n\r\nThe `Mastermind` should be initialized with a code. The code is an array of 4 elements, where each element is a colour. The array cannot be empty and must have always 4 elements, even if they are repeated.\r\n\r\nSince now we're designing our API (RED phase) we made the decision of having an `initilize` method our `Mastermind` class, that should receive our array. A good strategy to guide our tests when we are dealing with methods that handle collections is the **Zero-One-Many**. That means that we can first define how our code should work for `0` elements, `one` element and then `many` elements.\r\n\r\nOur AC says that the code should always have 4 elements, no more, no less. So lets write a test for 0 elements. In that case we should raise an error. We can do that as follows:\r\n\r\n```typescript\r\nlet initilizeGame = function() { game.initialize([]) };\r\n\r\nexpect(initilizeGame).toThrow();\r\n```\r\n\r\nHere we have an `assertion` and we're doing that by using the `expect` function and cascading that wit our condition `.toThrow`. That means, quite literally that we expect the function `initilizeGame` to throw an error when it's called.\r\n\r\nSince we're expecting an exception, we need to wrap our action code inside of a function, and then pass the wrapper function as an argument of `expect`.",
      "line": 7
    },
    {
      "file": "src/index.spec.ts",
      "description": "Now back to the **GREEN** phase, let's make the test pass. Let's add our new method, and since here we only care about being fast, let's make the method throw an error by default.\r\n\r\n```typescript\r\ninitialize(code) {\r\n    throw new Error(\"The code should have 4 elements.\");\r\n}\r\n```\r\n\r\nWe can verify that this makes the test pass by running `npm test` again. Another option is to run the following:\r\n\r\n>> npm run test:watch\r\n\r\nThis command will run the tests in *watch* mode, and the tests should re-run every time you save your changes.",
      "line": 14
    },
    {
      "file": "src/index.spec.ts",
      "description": "OK, the test is green, but this code is kind of bad, we should only throw this exception when the code is empty (as per our current tests). So lets use our **REFACTOR** phase here and make this a bit better by add a check on the length of our array. The `initialize` method should look something like this:\r\n\r\n```typescript\r\nif (code.length === 0) {\r\n    throw new Error(\"The code should have 4 elements.\");\r\n}\r\n```\r\n\r\nAfter implementing our changes we save the file and will check that the test still passes. This is very important, during the **REFACTOR** phase you want all your tests to pass, if any of your tests fails it means that you broke the expected behaviour and it's a good idea to roll back your changes and do the refactoring again.",
      "line": 15,
      "selection": {
        "start": {
          "line": 13,
          "character": 1
        },
        "end": {
          "line": 14,
          "character": 1
        }
      }
    }
  ]
}